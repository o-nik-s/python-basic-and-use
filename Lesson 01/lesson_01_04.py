# Пространства имён и области видимости
# Пространство имен - это сопоставление имен, переменных, функций и классов и реальных имен в оперативной памяти

# Пространство имен - все множество ссылко на объекты

# Каждый вызов функции создает новое пространство имен

# Когда функция вызывается, она создает локальный name space. В нем мы будем хранить аргументы функции и локальные переменные,
# объявленные внутри функции.

# Первое пространство имен создается когда мы запускаем интерпретатор. Оно содержит встроенные функции и классы.
# builtins: здесь мы можем найти все встроенные типы int, str, float, bool;
# все функции стандартной библиотеки: max, abs, id

# Второе пространство имен, которое создается,  - main space - оно является глобальным и содержит все те имена,
# которые мы объявили на самом верхнем уровне кода

# Локальные прострастранства имен
# Необходимость создавать связана с функциями, со стеком вызовов и с т.н. локальными переменными
# Мы хотим, объявляя функции, не бояться, что переменная, объявленная внутри, перезапишет переменную, записанную более глобально
# После окончания работы функции функция не только снимается со стека, но и разрушает соответствующий ей стек

# Основное правидо: в начале посмотри в самом локальном пространстве, затем в следующем, и только в самом конце -
# в глобальном и builtins.

# Такой механизм позволяет использовать одни и те же имена в разных местах программы


# Области видимости (scope)
# Области видимости - это такие текстовые фрагменты программы, в которых локальные фрагменты, которые Вы создаете,
# доступны напрямую

# Области видимости статичны и не зависят от работы программы
# Однака в процессе исполнения кода областям видимости соответствуют локальные простртанства имен,
# которые мы создаем при вызове функций

# Категории:
# локальный scope
# закрывающие scope - те, в которых мы находимся до глобального scope
# глобальный scope
# scope, соответствующий build-ins

# Для поиска переменной верно правило LEGN

# Можно заметить, что в рассматриваемом примере порядок обхода scope равен порядку обхода build-ins
# Однако очень важно понимать, что это не всегда так.

def a():
    print(x)

def b():
    x = 31
    a()

b()

# X не определена, несмотря на то, что внутри b мы объявили имя x

# Таким образом, поиск переменных осуществляется по пространствам имен,
# которые связаны с соответствующим им областям видимости
# Области видимости перебираем в порядке LEGN

# Local enclosed global built-in


# Локальные пространства имен не создаются, когда мы используем условный оператор или циклы
# Однако если по тем или иным причинам не зайдем внутрь условного оператора или цикла,
# то и имя в текущем пространстве имен не создадим


# Однако в функциях иногда хочется изменить значение глобальной переменной или переменной
# в пространстве имен вызвавшей нас функции.

# Для этого есть конструкции global и nonlocal.

# Хотим использовать переменную ok_status, если что-то пошло не так
# Для этого используется конструкция global

# global означает, что надо взять имя переменной из глобального name space и внутри нашей функции именно его использовать

def f():
    ok_status = True # Локальный name space
    vowels = ["a", "u", "i", "e", "o", "y"]

    # Проверяем слово на назождение в нем гласных
    def check(word):
        global ok_status
        for vowel in vowels:
            if vowel in word:
                return True

        ok_status = False
        return False

    print(check("abacabs"))
    print(ok_status)
    print(check("www"))  # False
    print(ok_status)  # True - ok_status is not global

f()
print(ok_status)  # False - global ok_status
# Мы хотели, чтобы переменная ok_status внутри функции говорила нам о том, как же исполняется наша функция,
# есть ли в ней какие-то проблемы исполнения.


# Однако если нам нужен статус работы функции /false - что-то пошло не так!/, то, описывая переменную как глобальную
# и изменяя переменную в подфункции, переменная в самой функции не изменится, что неправильно. Для таких случаев
# при описании переменной в локальной функции существует параметр nonlocal.

# Nonlocal говорит о том, что нужно найти такое пространство имен, которое содержало бы данную переменную, при этом
# ближайшее к текущему пространству имен по пути от текущего пространства имен до name space global.

def f():
    ok_status = True # Локальный name space
    vowels = ["a", "u", "i", "e", "o", "y"]

    # Проверяем слово на назождение в нем гласных
    def check(word):
        nonlocal ok_status
        for vowel in vowels:
            if vowel in word:
                return True

        ok_status = False
        return False

    print(check("abacabs"))
    print(ok_status)
    print(check("www"))  # False
    print(ok_status)  # False

f()
print(ok_status)  # NameError

# Важным моментом является то, что в процессе поиска конструкции nonlocal по пути от check до global мы никогда
# не будем смотреть ни в global ни в check, а будем проверять пространство имен от global дл check.
