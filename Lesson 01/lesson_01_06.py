# 1.6 Наследование классов

# Нужно тогда, когда мы хотим, чтобы наш объект вел себя так же как и объект другого типа за некоторым исключением.

# Например, мы хотим, чтобы класс вел себя так же как и листы, но при этом мы хотим, чтобы был дополнительный метод,
# который определяет, является ли число элементов в классе четным или не четным. И при этом мы не хотим писать класс с нуля.

# Наследование

# Синтаксис
'''class DerivedClassName(Base1, Base2, Base3): # В скобках после имени класса указываем классы, от которых мы наследуемся
    <statement-1>

    <statement-N>'''

# Пример
class MyList(list): # Описываем новый класс
    def even_length(self): # Описываем метод, проверяющий, является данный лист четной длины
        return len(self) % 2 == 0

x = MyList()
print(x)
x.extend([1, 2, 3, 4, 5]) # Хотя и не описывали в классе, можем его использовать
# Когда не находим имя внутри пространства экзмепляра и класса, смотрим и проверяем имя в пространстве классов, от которых мы наследовались,
# и находим его там
print(x)
print(x.even_length())
x.append(6)
print(x.even_length())
print()

# Пайтон поддерживает множественное наследование
# Это значит, что когда мы создаем класс, мы можем выбрать несколько классов, от которых будет наследоваться наш класс

class D: pass
class E: pass
class B(D, E): pass
class C: pass
class A(B, C): pass

# Если мы явно не наследуем класс от какого-либо класса, то класс наследуется от класса Object.

# Классы, от которых мы наследуемся, - родители или родительские классы
# Родители, родители родителей и т.д. - предки класса

# Класс object являет предком любого класса

# Для проверки наследования существует функция
# issubclass(class1, class2) # Проверяет, что первый агрумент является наследником второго класса

print(issubclass(A, A)) # True
print(issubclass(C, D)) # False
print(issubclass(A, D)) # True
print(issubclass(C, object)) # True
print(issubclass(object, C)) # False
print()

# Чаще всего более интересно знать, ведет ли себя объект как экземпляр какого-либо класса
# Для этого в языке Пайтон есть функция isinstance

# isinstance отвечает на вопрос, является ли тип первого аргумента наследником второго аргумента
# Хотим узнать, можем ли мы использовать данный объект в качестве объекта данного типа

y = A()  # Создали экземпляр класса
print(isinstance(y, A))  # True
print(isinstance(y, B))  # True
print(isinstance(y, object))  # True
print(isinstance(y, str))  # False
print()

# В примере выше: можем ли мы использовать объект x с типом MyList в качестве обычного List?
print(isinstance(x, list))
# Таким образом, x мы можем использовать и в качестве list.
# Таким образом, то, как мы можем использовать экземпляр класса, зависит не лишь от класса,
# но и от классов, от которых он наследуется.


# Если x - экземпляр A(), и мы пытаемся вызвать у x какой-нибудь метод, который не является атрибутом
# экземпляра x, и который не является атрибутом нашего класса A().
# Тогда если для A() использовали множественное наследование, в каком же из классов, от которых мы наследуемся, мы должны найти ту функцию,
# которая будет связана с методом нашего объекта x.


# Когда мы вызываем конструктор, он пытается найти метод __init__(self, ...), чтобы проинициализировать тот экземпляр, который создается.
# Т.к. init не находится в MyList, то запускается конструктор в List

# Когда мы вызываем print() экземпляра, интерпретатор пытается найти внутри экзепляра метод __repr__() /от англ. representation или представление/
# Этот метод должен возвращать строковое представление объекта, которое мы будем выводить в консоль при print(), например
# И когда мы не находим его в MyList, мы ищем его в List

''' Из комментариев. При вызове print всегда вызывается метод __str__ обьекта, но если __str__ не определен в вашем классе 
вызовется __str__ класса object который внутри себя вызывает уже self.__repr__:'''


# Очень важно понимать порядок, в котором мы будем перебирать классы, когда мы ищем функцию, чтобы связать с методом
# Особенно это важно понимать, когда мы используем множественное наследование

# Для решения подобных конфликтов в Пайтон есть порядок разрешения методов
# Порядок разрешения методов определяется в момент создания класса
# Мы можем вывести его с помощью метода mro(), который есть у любого класса
# mro - сокращение от method resolution order - порядок разрешения методов

print(A.mro()) # Выведет список классов - этот того порядок, который будем перебирать, когда ищем метод
print()

# Порядок разрешения методов гарантирует, что кажлый предок нашего класса будет в единственном числе

# Родительские классы будут следовать в том же порядке, который был указан в скобках слева направо

# Пример
class EvenLengthMixin: # Описываем новый класс
    def even_length(self): # Описываем метод, проверяющий, является данный лист четной длины
        return len(self) % 2 == 0

class MyList(list, EvenLengthMixin):
    pass

print(MyList.mro())
x = MyList([1, 2, 3])
print(x.even_length())
x.append(4)
print(x.even_length())
print()

# Преимущество использования EvenLengthMixin: В качестве класса, которому мы добавляем функциональность, подойдет любой класс, у которого есть длина
# /кроме списка, например, строка или словарь/.

class MyDict(dict, EvenLengthMixin):
    pass

x = MyDict()
x["key"] = "value"
x["another key"] = "another value"
print(x.even_length())
print()

# Что случится, если мы попробуем определить в нашем классе метод с таким же именем, как в одном их родительских классов?

class MyList(list, EvenLengthMixin):
    def pop(self): # Стандартный метод pop() определен внутри List и возвращает последний элемент списка и этот список сокращает на данный элемент
        x = super(MyList, self).pop()  # Два аргумента: класс, родителя которого мы хотим проверить; объект, с которым мы хотим проассоциировать метод
        print('List value is', x)
        return x

ml = MyList([1, 2, 4, 17])
z = ml.pop() # Этот pop() будет проассоциирован из класса MyList
print(z)
print(ml)

# Однако иногда есть необходимость вызвать элекмент как будто он не опрелен в нашем классе, а определен в одном из родительских
# Для этого есть функция super(), которая принимает два аргумента: класс, родителя которого мы хотим проверить; объект, с которым мы хотим проассоциировать метод

# Таким образом, в случае super(MyList, self).pop() мы пойдем искать метод pop() в родителях класса MyList в том же порядке, в котором они
# перечислены в порядке исключения методов, исключая сам MyList. А затем функцию, которую мы найдем, мы проассоциируем с объектом self.
# Эта запись эквивалентна list.pop(pop).

# Порядок разрешения методов в Python: https://habrahabr.ru/post/62203/
# И здесь: https://en.wikipedia.org/wiki/C3_linearization

'''Для запоминания порядка MRO:
1) если среди родителей класса - два класса, которые являются прямыми "родственниками", 
причём "родитель" перечислен до "потомка" - то возникает ошибка.  Потому, как - вроде программист 
определяет такой  порядок, а MRO предусматривает обратный (т.е. сначала "потомки" - потом "родители").

P.S. (1) Конечно, разработчикам можно было и избегать ошибки, самостоятельно определяя что приоритетнее 
- но это противоречит "Дзену Python'а" (явное лучше подразумеваемого) - а потому, python заставляет 
программиста точно определиться - либо поменять порядок, либо выкинуть один из классов из списка родителей..

2) если же предыдущее правило не нарушается, то MRO строится "слева --> направо" до ближайшего 
"общего родителя". Все "родители" должны расположится после своих "прямых" и "опосредованных" 
потомков, но как можно левее (раньше).
 
P.S. (2) Получается что-то похожее на рекурсию или алгоритм класса "разделяй и властвуй", 
когда модель графа наследования делятся на кусочки до "ближайшего общего родителя", 
выполняется построение до этого "общего родителя", а потом этот "родитель" рассматривается как отдельный узел графа 
для выстраивания последующего порядка разрешения методов..

'''

