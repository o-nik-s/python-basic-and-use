# Функции и стек вызовов

'''Причины использования функций
1. Переимпользование кода
2. Структурирование кода
3. Сокрытие деталей реализации'''

# def - define - определение
# Определение функции в Пайтон не выполняется построчно, оно выполняется целиком
# Поэтому сначала интерпретатор дочитывает то того места, где функция заканчивается
# И лишь затем, когда будет считан и выполнен код определения функции, будет создано тело для функции

def function_name(argument1, argument2):
    # function_body
    return argument1 + argument2
x = function_name(2, 8)
y = function_name(x, 21)
print(y)


# Функции в Пайтон так же являются объектами
print(type(function_name))
print(id(function_name))

# Определяет переменную с именем функции и создает для нее объект в памяти

# До исполнения тела функции всегда происходит иниципализация аргументов
# Код функции будет исполняться построчно

# x = function_name(2, 8) : результатом будет ничто иное как ссылка на 10

# Так же стоит помнить, что функция print является объектом в ОП.


a = []
def foo(arg1, arg2):
  a.append("foo")
foo(a.append("arg1"), a.append("arg2"))
print(a)

# Стек вызовов - он же машинный стек - он же структура данных
# push: что-то кладем в стек
# pop: что-то забираем из стека

# Стек вызовов хранит прежде всего функции, которые мы вызвали

# В замом низу функции хранится функция module

# Все функции в стеке вызовов на самом деле исполняются
# Но на самом деле одна функция исполняется реально, а все остальные функции ждут выполнения других функция

x = [1, 2, 3]

x.append(4)
x.append(5)
print(x)

top = x.pop()  # Удаляет последний элемент из конца списка
print(top)
print(x)

# Если к списку применяли только методы append и pop, то данный список ведет себя точно так же как и стек


# Для возвращения значения функции - конструкция return

# После return выполнение функции заканчивается, даже если впоследствии было еще несколько return

# Если функция ничего не вернула (пустой return или его вообще нет), то результат работы будет ссылатьс яна объект None

x = print(4)  # Результат работы будет ссылаться на None

type(None)  # Равен NoneType
# В памяти всегда хранится только один объект None

# x is None # Проверка, ссылается ли x на None


def printab(a, b):
    print(a)
    print(b)

printab(10, 20)  # Аргументы позиционные - передача по позиции
printab(a = 30, b = 40)  # Именнованные аргументы - передача по имени
# В начале надо передавать позиционные аргументы, а затем - именнованные

# Можно передавать элементы списков в качестве аргументов функции

lst = [50, 60]
print('*lst')
printab(*lst)  # Передача в качестве аргументов списка /для позиционных аргументов/

print('**lst')
args = {'a': 70, 'b': 80}
printab(**args)  # В качестве args - кортеж или список
#  Подобная конструкция раскрывается в список вида ключ - значение; ключ - значение /a = 70 и b = 80/

# Прием аргументов

def printab(a, b):
    print(a)
    print(b)

def printab(a, b=10): # b=10 - значение по умолчанию
    print(a)
    print(b)

def printab(a=10, b=10):  # Можно вызывать функцию без аргументов
    print(a)
    print(b)

# Неправильно!
# def printab(a=10, b):  # b является вторым позиционным аргументом, т.е. нужно указывать a!
#     print(a)
#     print(b)


# Хотим передать неопределенное число аргументо
# Например, хотим найти минимум из чисел

def printab(a, b, *args):  # В *args может быть неопределенное число аргументов
    print("positional argument a", a)
    print("positional argument b", b)
    print("additional arguments:")
    for arg in args:
        print(arg)

printab(10, 20, 30, 40, 50)

# В args попадут все переданные позиционные аргументы
# Находиться они там будут именно в том порядке, в котором мы их передали

def printab(a, b, **kwargs): # ВОзьми  все именнованные аргументы, которые не участвовали в инициализации, и передай иъ в словарь kwargs
    print("positional argument a", a)
    print("positional argument b", b)
    print("additional arguments:")
    for key in kwargs:
        print(key, kwargs[key])

printab(10, 20, c=30, d=40, jimmi=123)

# В kwargs попадают элементы, которые не участвовали в инициализации
# Вывод функции не изменится с точностью до перебора ключей внутри словаря

# Синтаксически верное определение любой функции
def function_name([positional_args, # a, b, c
                  [positional_args_with_default, # d=0, e=True
                  [*pos_args_name, # *args, *lst
                  [keyword_only_args, # которые мы можем предать только по имени^ f, g, h=10 /позиционных здесь не может быть, все должны быть переданы по имени/
                  [**kw_args_name]]]]]]) # все именнованные аргументы, которые в инициализации не поучаствовали

def printab(a, b=10, *args, c=10, d, **kwargs):
    print(a, b, c, d)

printab(15, d = 15)

# В теле функции можно использовать другие функции
# Если функция x вызывает функцию x, то такая функция называется рекурсивной
