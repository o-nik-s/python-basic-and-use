# Итераторы и генераторы

# iteration.py

# Если мы хотим перебирать элементы объекта X с помощью цикла for, то необходимо, чтобы у нашего объекта X был итератор
# Итератор - это такой объект-перечислитель

# Итератор перебирает элементы по очереди. А когда они заканчиваются, выбрасывает ошибку StopIteration.

# У итератора можно спросить, какой объект следующий
# Если объекты заканчиваются, то бросается ошибка StopIteration

# Для получения итератора в Пайтон необходимо использовать функцию iter()
# Для получения следующего элемента используется функция next()

# На самом деле именно таким образом и работает цикл for
# Когда мы перебираем элементы множества с помощью цикла for, мы сначала просим(?) итератор этого множества,
# а затем с помощью цикла for перебираем элементы

# См. пример из iteration.py

# Понимание того, что мы используем итераторы и функцию next() для перебора элементов, позволит нам писать свои собственные
# итераторы для перебора элементов нашмих собственных классов

# Давайте напишем простой объект итератора
# См. пример range.py

# Для того, чтобы экземпляр класса стал итератором, необходимо внутри нашего класса определить метод __next__()
from random import random

class RandomIterator():
    def __iter__(self):
        return self

    def __init__(self, k): # k - необходимое количество итераций
        self.k = k
        self.i = 0 # Число уже перечисленных итератором  случайных чисел

    # pass
    # Для того, чтобы экземпляр класса стал итератором, необходимо внутри нашего класса определить метод __next__()
    def __next__(self):
        # return 0
        if self.i < self.k:
            self.i += 1
            return random()
        else:
            raise StopIteration


x = RandomIterator(3)
print(next(x))  # next(x) ~/эквивалентно/ x.__next()__;  x - iterator, когда у него есть данный метод next()
print(next(x))
print(next(x))
# print(next(x))

iter(x)
print()

# Теперь определим нужную нам функциональность
# Мы хотим, чтобы вместо нуля возвращалось случайное значение из диапазона [0, 1]

# В данный момент времени данный итератор будет генерировать последовательность бесконечно,
# потому как мы не определили у него момент времени для бросания ошибки StopIteration

# Для определения окончания итерации напишем конструктор класса

# Для того, чтобы использовать итератор в цикле for(), мы должны уметь вызывать функцию iter() от нашего объекта x: iter(x)
# Для этого внутри класса нужно определить метод __iter__

# Функция __iter__ должна возвращать экземпляр итератора.
# Поэтому в случае с итераторами чаще всего метод iter возвращает именно self, а в случае с классами, которые мы хотим перебирать,
# мы возвращаем именно экземпляр итератора

for x in RandomIterator(10):
    print(x)

# Итак, для того, чтобы объект можно было проитерировать, у него должен быть определен метод iter(), который возвращает нам итератор
# А для того, чтобы объект являлся итератором, у него должен быть определен метод next()



# Давайте попробуем определить, как ведет себя метод iter для какого-нибудь нашего собственного класса
# См. прмием lst.py

# Давайте попробуем определить, как ведет себя метод iter для какого-нибудь нашего собственного класса
class DoubleElementListIterator:
    def __init__(self, lst):
        self.lst = lst # Список элементов, которые мы хотим перебирать парами
        self.i = 0 # ЧИсло элементов, которые мы уже перебрали

    def __next__(self):
        if self.i < len(self.lst):
            self.i += 2
            return self.lst[self.i - 2], self.lst[self.i - 1]
        else:
            raise StopIteration


class MyList(list):
    # pass
    def __iter__(self):
        return DoubleElementListIterator(self)

# Стоит отметить, что метод __iter__() уже определен в нашем классе List
# ПОэтому если в MyList стоит pass, то перебор элементов экземпляра ведет себя точно так же как перебор элемента списка

# Поэтому есть необходимость определять свой собственный метод __iter__, который будет возвращать нам итератор,
# который бы вел себя нужным нам образом

for pair in MyList([1, 2, 3, 4, 5]):
    print(pair)

# Мы смогли сами определить поведение для класса, если мы перебираем в нем элементы с помощью цикла for



# Однако для написания итераторов приходится использовать классы
# Можем ли мы сделать это проще?
# Это делается с помощью генераторов

# Генератор - это фукнции, в которых вместо return мы используем слово yeld
# И вместо того, чтобы значение возвращать, она будет генерировать нам следующее значение

# См. generators.py

# Таким образом, отличие генератора от обычной функции заключается в том, что с помощью ключевого слова yeald,
# которое мы используем вместо return, мы можем вернуть значение функции несколько раз
# А спрашивать, какое значение будет следующим, мы будем с помощью функции next

# Так же надо понимать, что инетрпретатор смотри сразу на все тело функции
# И если он видит там yield, то понимает, что эта функция является генератором
# А вызов генератора ведет себя не так, как вызов обычно функции

from random import random


class RandomIterator:
    def __iter__(self):
        return self

    def __init__(self, k):
        self.k = k
        self.i = 0

    def __next__(self):
        if self.i < self.k:
            self.i += 1
            return random()
        else:
            raise StopIteration


def random_generator(k):
    for i in range(k):
        yield random()
gen = random_generator(3)
print(type(gen)) #  <class 'generator'>

# Когда мы вызываем функцию с yield внутри, у нас вызывается объект генератор
# Этот объект генератор примечателен тем, что знает целиком все тело функции
# И исполнение генератора начнется лишь тогда, когда мы попросим следующий элемент
# Когда мы его попросим, он начнет с самого начала исполнять нашу функцию до первого ключевого слова yield
# Когда он встретит слово yield, он вернет значение наружу, туда, где мы зызвали функцию next
# Но что самое главное, когда мы возвращаем значение, мы так же запоминаем и все состояние нашей функции
# Чтобы затем, когда next будет вызван в следующий раз, продолжить выполнение не с начала функции,
# а с того места, где мы до этого остановились
# Затем, если в какой-то момент времени мы не найдем ключевое слово yield, мы бросим ошибку StopIteration


def simple_gen():
    print("Checkpoint 1")
    yield 1
    print("Checkpoint 2")
    yield 2
    print("Checkpoint 3")

gen = simple_gen() # КОгда мы получаем объект генератора, никакой код из тела функции даже еще не начинает исполняться
x = next(gen)
print(x)
y = next(gen)
print(y)
# z = next(gen)
print()

# Таким образом, с помощью генераторов в Пайтон реализуется концепция отложенного исполнения
# Мы продолжен исполнение функции лишь тогда, когда нам в действительности понадобится следующее значение


def random_generator(k):
    for i in range(k): # k раз возвращает нам случайное значение из промежутка [0, 1]
        yield random()
gen = random_generator(3)
print(type(gen)) #  <class 'generator'>
for i in gen:
    print(i)
print()

# Таким образом, генератор - это удобный синстаксис для написания итераторов
# Вместо описания класоа, внутри котого нужно обязательно реализовать два метода - iter и next,
# мы написали маленькую функцию, которая принимает всего один аргумент и вместо return использует yield,
# тем самым говоря о том, что будет возвращать несколько значений, которые нужно вернуть из функции

# Что будет, если вставить в генератор return?
# return будет срабатывать как конец функции /StopIteration/

def simple_gen():
    print("Checkpoint 1")
    yield 1
    print("Checkpoint 2")
    return "No more elements"
    yield 2
    print("Checkpoint 3")

gen = simple_gen() # КОгда мы получаем объект генератора, никакой код из тела функции даже еще не начинает исполняться
x = next(gen)
print(x)
y = next(gen)
print(y)
z = next(gen)

# То, что мы добавим в return, будет сообщением внутри StopIteration

# Таким образом, генератор в Пайтоне, - это такой удобный синтексис для написания итераторов
# Он ведет себя почти так же как и функция, но при этом с помощью конструкции yield
# мы можем возвращать сразу несколько значений из функции

# Важно помнить, что исполнение функции происходит лись с помощью вызова next(). И происходит от одного вызова до следующего.
# А если next() не нашел, то тогда генератор заканчивает свое выполнение и бросает ошибку StopIteration

# Итератор - класс, генератор - функция.


# Очень часто в Пайтон возникает необходимость возникать списки
# Для этого существует list comprehension - генерация списков

# Пусть есть список
x = [-2, -1, 0, 1, 2]
# Мы хотим список, содержащий квадраты данных значений
y = []
for i in x:
    y.append(i**2)
print(y)

# Однако в Пайтон есть синтаксис, который позволяет сделать это сильно проще
# Мы модем объявить содержимое списка прямо внутри списка, используя list comprehension

# [<что нам нужно> <откуда взять переменную>]
y = [i * i for i in x]
print(y)

# Так же внутри данного конструктора листа мы можем использовать условный оператор if
# Мы можем добавить данный элемент только в том случае, если выполняется условие
y = [i * i for i in x if i > 0]
print(y)

# Как же в общем случае должна выглядеть такая генерация списков?
# [<Что мы должны поместить в список> <for: мы перебираем элементы из множества или итератора>
#     <затем может быть еще несколько циклов for> <Условный оператор if, при истинности которого элемент помещается в список>]

z = [(x, y) for x in range(3) for y in range(3) if y >= x]
print(z)
# Эквивалентно
z = []
for x in range(3):
    for y in range(3):
        if y >= x:
            z.append((x, y))
print(z)

# Если мы данную конструкцию поместим в круглые скобки вместо квадратных, то мы получим генератор, который будет перебирать
# подходящие по условию объекты
z = ((x, y) for x in range(3) for y in range(3) if y >= x)
print(z)
print(next(z))
print(next(z))

