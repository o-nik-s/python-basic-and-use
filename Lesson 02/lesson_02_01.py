# 2.1 Ошибки и исключения

# Ошибки в Пайтон:
# 1 тип. Ошибки синтаксические.
# 2 тип. Ошибки в процессе исполнения самого кода. Т.н. исключения.

# NameError - Ошибка, когда мы не можем найти имя в пространстве имен

# Возьмем наш пример
class EvenLengthMixin:
    def even_length(self):
        return len(self) % 2 == 0

class MyList(list, EvenLengthMixin):
    pass

ml = MyList([1, 12, 4, 17])
ml.sort()
print(ml)
print()

# При запуске: PyCharm знает путь до нтерпретатора, знает путь до текущего открытого файла,
# и запускает исполняемый файл, передав аргументы

# Когда допустим синтаксическую ошибку в файле, увидим, что PyCharm умеет распознавать синтаксические ошибки.


# Важно помнить, что файл целиком проверяется на синтаксические ошибки. Т.е. если синтаксические ошибки есть,
# то файл не начнет свое исполнение.
# Если синтаксических ошибок нет, то программа начнет исполнение строка за строкой.

# Таким образом, синтаксические ошибки - это единственные ошибки, о которых мы можем узнать до исполнения самого кода.
# О всех остальных ошибках мы можем узнать лишь в процессе исполнения.


# У любой ошибки в Пайтон есть три обязательные вещи:

# 1. Ошибки так же являются объектами, поэтому поэтому у любой ошибки есть тип. Тип ошибки уже о многом нам говорит.
# Если мы встречаем typeerror, то мы, вероятно, передали в какую-нибудь функцию что-нибудь неправильного типа.
# А если мы встречаем nameerror, то мы, вероятно, попытались использовать переменную, которая еще не определена.

# 2. Так же у любой ошибки в Пайтон есть дополнительное сообщение, которое несет дополнительную информацию и часто может
# нам помочь понять, что же пошло не так.

# 3. Состояние стека вызовов на тот момент, когда у нас совершилась ошибка.

# x = [1, 2, 3]
# print(x[4])

# Ошибки нужны для того, чтобы сообщить нам о том, что в нашем коде произошло что-то такое, из-за чего
# мы больше не можем продолжить работу.

# Тип ошибки: IndexError  - В нашем коде
# Дополнительное сообщение: list index out of range  - Что именно произошло?
# Состояние стэка: В 47 линии нашегй главной функции <module> мы пытаемся вызвать print(x(4)). И когда мы пытаемся
# распознать аргумент, мы получаем IndexError. - Где именно произошло?

# def f():
#     x = [1, 2, 3]
#     print(x[4])
# f()
# Увидели развернутый стэк вызовов


# Некоторую часть ошибок можно поймать и обработать
# с помощью обработки исключений

try:
    x = [1, 2, "hello", 7]
    x.sort()
    print(x)
except TypeError:  # Ожидаемый тип исключения
    print("Type error :(")  # Что же делать, если TypeError действительно возник внутри try

print("I can catch")
print()

# Зашли в try, попыли на ошибку, вывели сообщение, а после этого успешно продолжили выполнять код до конца


# Мы решаем, что возникновение ошибки в том месте мы считаем не критичным чтобы совсем останавливать выполнение всей программы
# Конструкция try - except позволяет нам выбрать типы ошибок, которые мы считаем не критичными, как-то их обработать,
# а затем продолжить исполнение кода

def f(x, y):
    try:
        return x / y
    except TypeError:
        print("Type error")
    except ZeroDivisionError:
        print("Zero division :(")

f(5, [])
f(5, "123")

print(f(5, 0))
print()
# Другой тип ошибки!

# Если мы некоторый тип ошибки не ловим, то ошибка вылетает

# ПОсле обработки исключения
# Раз функция не вернула значение, что мы пишем на экран None

# Важео помнить, что любое исключение будет обработано лишь одним из них - первым, под которое ошибка подойдет
# Остальные блоки не будут исполняться

# Важно помнить, что мы можем поймать ошибку в любом месте исполнения на стеке
# Т.е. не только функции, а и основной программы

def f(x, y):
    try:
        return x / y
    except TypeError:
        print("Type error")

try:
    print(f(5, 0))
except ZeroDivisionError:
    print("Zero division :(")
print()

# Однако мы можем поймать одним except блоком сразу несколько типов исключений
# Для этого нужно передавать в except кортеж, содержащий типы данных исключений

def f(x, y):
    try:
        return x / y
    except (TypeError, ZeroDivisionError):
        print("Error :(")

print(f(5, 0))
print(f(5, []))
print()

# Так же можем поймать и сам оббъект ошибки. Для этого после типа ошибки нужно указать as и имя объекта
def f(x, y):
    try:
        return x / y
    except (TypeError, ZeroDivisionError) as e: # Теперь внутри except будет содержаться тип ошибки
        print(type(e))
        print(e)
        print(e.args)

print(f(5, 0))
print(f(5, []))
print()

'''<class 'ZeroDivisionError'> - тип данной ошибки - это класс
division by zero = строковое представление ошибки
('division by zero',) - аргументы, с которыми мы создавали экземпляр класса
None
'''

# Если не знаем, что именно ловить, можем использовать пустой except. Тогда он выведет любую ошибку, которую поймает.
def f(x, y):
    try:
        return x / y
    except: # Теперь внутри except будет содержаться тип ошибки
        print("Error :(")

print(f(5, 0))
print(f(5, []))
print()

try:
    15 / 0  # Вот здесь внутри блока try генерируется объект исключения, когда мы пытаемся разделить на ноль.
    # У него нет имени, пусть мы назовем его e
except ZeroDivisionError:  # Проверяет, isinstance(e, ZeroDivisionError) == True /если несколько типов, то проверяет для каждого/
    print('Division by zero')
print()

# Почему мы не используем сравнение типов через type, а запускаем isinstance()
# Дело в том, что все ошибки в Пайтон представляют собой иерархию
# И, например, ZeroDivisionError наследуется от класса ArithmeticError, т.е.является арифметической ошибкий

print(ZeroDivisionError.mro()) # Выведем порядок разрешения методов для ZeroDivisionError

# В Пайтон ошибки не используют множественное наследование

try:
    15 / 0  # Вот здесь внутри блока try генерируется объект исключения, когда мы пытаемся разделить на ноль.
    # У него нет имени, пусть мы назовем его e
except ArithmeticError:  # Проверяет, isinstance(e, ZeroDivisionError) == True /если несколько типов, то проверяет для каждого/
    print('Arithmetic Error :(')
print()

# isinstance - проверка объекта, ведет ли себя как экземпляр класса

try:
    15 / 0
except ArithmeticError:
    print('Arithmetic Error :(')
except ZeroDivisionError:  # Бессмысленно, т.к. все арифметические ошибки мы уже поймали выше
    print("Zero division")
print()

# Ключевое слово else используется тогда, когда в try не возникла никакого исключения, и мы хотим что-то сделать в этом случае
# А блок finally запускается в любом случае, когда мы обработали исключение, когда исключения не было, и даже когда было такое исключение,
# которое мы обработать не смогли

# Собрали все воедино
def divide(x, y):
    try:
        result = x / y
    except ZeroDivisionError:
        print("Division by zero")
    else:
        print("result is", result)
    finally:
        print("finally")

divide(2, 1)
divide(2, 0)
# divide(2, []) # Сначала исполнился блок finally, и затем наша программа упала
print()


# Ранее мы пользовались только стандартными исключениями
# Однако мы вправе сами решать, когда в нашей программе произошла ошибка, которую необходимо обработать
# Кроме того, что ловить исключения, можно их бросать

# Throw and catch /кидать и ловить/

# Для того, чтобы бросить исключение, нужно использовать конструкцию raise, в которую нужно затем передать
# объект нашего исключения

def greet(name):
    if name[0].isupper(): # Проверяем, с заглавной ли буквы
        return "Hello, " + name
    else: # Не с заглавной
        raise ValueError(name + " is inappropriate name")

print(greet("Anton"))
# print(greet("anton"))

# Идеологически в Питоне ValueError используется тогда, когда аргумент, который мы передали в функцию,
# по типу в общем-то подходит, а вот по значению - нет

# Идеологически ValueError используется тогда, когда аргумент, который мы передали в функцию, по типу в общем-то подходит,
# а вот по значению - нет.

# Конструктор класса ValueError принимает строку, которая является сообщением дополнительным к этому исключению

while True:
    try:
        name = input("Please enter your name: ")
        greeting = greet(name)
        print(greeting)
    except ValueError:
        print("Please try again")
    else:
        break

# Все исключения, которые мы бросаем с помощью raise и ловим с помощью except, должны быть экземплярами класса BaseException.
# BaseException - это встроенный тип языка Пайтон, который описывает все исключения языка Пайтон

# Представим, что нет такого класса исключений, который бы хорошо описывал именно ту ошибку, которая происходит у Вас в коде
# Тогда имеет смысл написать свой собственный класс исключений именно для этой ситуации

class BadName(Exception):
    pass

def greet(name):
    if name[0].isupper(): # Проверяем, с заглавной ли буквы
        return "Hello, " + name
    else: # Не с заглавной
        raise BadName(name + " is inappropriate name")

print(greet("Anton"))
print(greet("anton")) # Код остановит свою работу из-за нашего класса исключений BadName
# Такое название нашего класса исключений проливает чуть больше света на то, что же действительно
# произошло в нашем коде


# Таким образом, чтобы бросить исключение в Пайтон, мы должны использовать конструкцию raise,
# а если мы хотим описать свой собственный класс исключений, то мы должны использовать
# наследование от класса exception

