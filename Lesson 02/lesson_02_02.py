# Работа с кодом: модули и импорт

# Очень часто возникает необходимость использовать функции, классы или какие-то переменные, которые мы объявили
# в одном файле, внутри другого файла.
# Для этого в Пайтон есть модули и есть импорт.

# Мы поместили некоторое определение классов и функций внутри файла exceptions.py. Именно этот файл мы и называем модулем.
# Однако имя модуля - это имя класса без расширения py. Т.е. exceptions.

# Таким образом, мы можем поместить любой код в имя_файла.py, а затем его импортировать.

# Важно понимать, как происходит сам процесс импортирования.
# Когда мы пишем import module мы берем файл module.py и целиком его исполняем.
# Те имена, которые останутся в пространестве имен, связанные с исполнением данного модуля, мы затем и сможем импортировать.

# Итак, код исполняется, когда мы его импортируем

# Какие проблемы при этом могут возникнуть?

# 1. Код в модуле может содержать в себе определения классов и функций, а так же и вычисления не нужных нам значений,
# которые могут считаться долго

# Нам очень хочется разграничивать тото код, который мы будем выполнять при импорте, от того кода,
# который выполнять при импорте не стоило бы
# Для этого внутри модуля нам всегда доступно глобальное имя name
# Когда мы запустим данный код, мы увидем текущее имя нашего модуля (в д. сл. - "__main__")

# А если мы попробуем импртировать, то имя модуля внутри модуля (fib) изменится на само имя модуля

# Таким образом, чтобы сравнить, когда мы испортируем, а когда - запускаем в интерпретаторе, необходимо просто сравнить
# текущее имя name

# Однако мы всегда можем убедиться, что импортировали нужную функцию
# Для этого достаточно ее выполнить

# Таким образом, при импорте будет исполняться только код выше условия "if __name__ == "__main__":"



# Импортировать код мы будем лишь единожды
# И все глобальные имена, которые остались внутри данного namespace, мы закрепим за нашим объектом модуля
# А если мы во второй разз напишем импорт того же модуля, то мы будем использовать тот же объект модуля

# Стоит отметить, что есть такой объект как sysmodules, и он на самом деле обычный словарь.
# Ключами у него являются имена наших модулей, а значениями - module objects

# И когда мы пишем import имя_модуля, Питон ищет модуль в словаре. Если не находит, исполняет и затем добавляет в словарь.
# Если находит, возвращает существующий module object

# import check
# import sys
# print(type(sys.modules))
# print(id(check))
# import check
# print(id(check))

# Таким образом, любой модуль будет импортирован лишь единожды, даже если импорт написан несколько раз

# Как мы ищем имя модуля, если мы не нашли его в sys.modules
# Тогда мы попробуем найти в файле.py в текущей директории
# Если мы не нашли его здесь, то пойдем искать во внешней библиотеке

# Для того, чтобы определить, в каком порядке это будет происходить, мы можем переблать все пути в sys.path
import sys

for path in sys.path:
    print(path)

# Внешние библиотеки так же можно найти в PyCharm
# Таким образом, библиотека python3.4 содержит в себе модули, которые являются стандартной библиотекой Пайтон
# Библиотка dist-pachages - дополнительно установленные модули

# В библиотеке почти все модули представлены папками. Эти папки мы называем пакетами.
# Пакеты - это удобный способ представления некоторого числа файлов в качестве одного модуля

# Пакета - это такие папки, которые можно испортировать как модули
# Интерпретатор определяет, является ли папка пакетом, по н наличию __init__ внутри
# Если внутри есть __init__, то он исполняется при импорте

# Таким образом, у неас есть модули и пакеты, которые ведут себя как модули


# Так же в Пайтон мы можем импортировать не весь модуль целиком, а лишь какие-то имена из него
# Для этого необходимо использовать конструкцию
# from модуль import имя_класса/имя_функции
from exceptions import BadName, greet
print(BadName)
print(greet)

# Так как с процессом импорта связано создание имени, мы можем явно указать локальное имя, которое мы хотели бы использовать
# Для этого следует указать "предикат" /конструкцию/ as
# Это позволяет работать с функциями/классами с одинаковыми именами в разных модулях

# Кроме того, другое имя можно передать самому модулю
import exceptions as exc

# Так же можно импортировать все именя какого-то модуля
from exceptions import *

# Однако так все равно можно испортировать не все имена
# Во-первых, можно определить конструкцию __all__, в которой определим те имена, которые можно испортировать с помощью *
# Во-вторых, даже если мы такую конструкцию не определим, мы не можем импортировать имена, начинающиеся с нижнего подчеркивания
# /Т.е. указали константу, начиная с "_", и тогда она тоже не будет импортирована с помощью *./


# Может оказаться, что для решаемой задачи не хватает стандартных средств языка Python
# Однако для уже распространенных задач есть пакеты, которые можно переиспользовать

# PyPI - the Python Package Index - Индекс пакетов языка Пайтон

'''
Установка утилиты pip

Утилита pip позволит нам устанавливать пакеты из репозитория Python Package Index: https://pypi.python.org/pypi

Если вы устанавливали python версии 3.4 или выше, то у вас уже должен быть установлен pip.

Чтобы это проверить, вы можете запустить
$ pip --version
# или
$ pip3 --version
такая команда выведет текущую версию утилиты pip, а также папку, в которую будут устанавливаться пакеты. 
Убедитесь что в пути до данной папки, указана верная версия вашего интерпретатора.

Если же не установлена (или путь до папки содержит другую версию интерпретатора), то вы можете перейти на сайт 
https://pip.pypa.io/en/latest/installing/ и найти там инструкции по установке утилиты pip: а именно скачать с сайта 
файл get-pip.py, и запустить его с помощью своего интерпретатора python. Если у вас на операционной системе 
несколько интерпретаторов, то убедитесь, что вы запустили файл get-pip.py, используя правильный 
(интерпретатор языка python3 может называться, как python, так и python3, в зависимости от вашей операционной системы). 

Чтобы убедиться в том, что вы установили pip, попробуйте запустить инструкцию выше.

Для того, чтобы установить какую-нибудь библиотеку из Python Package Index (например пакет simple-crypt 
из следующей задачи), необходимо запустить команду 
$ pip install simple-crypt

Если операционная система linux скажет, что вам не хватает прав для данной операции, используйте команду
$ sudo pip install simple-crypt

Утилита pip очень понадобится нам в третьем модуле для установки различных библиотек, поэтому если у вас возникла проблема 
с установкой данной утилиты, пожалуйста, напишите это в комментариях. 
'''

