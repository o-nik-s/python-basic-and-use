# Работа с файловой системой и файлами

# Мы рассматриваем два типа файлов:
# 1 тип файлов - текстовые
# Мы считаем, что содержимое данных файлов является текстом и может быть интерпретировано в качестве текстов
#

# 2 тип файлов - бинарные / двоичные /mp3, картинки, gifки и пр./
# Содержимое не можем интерпретировать в качестве текста
# Для "любого" бинарного файла существуют библиотеки, которые умеет с файлами данных форматов работать
# Для графики библиотека pilow
# Для музики библиотеки wave, pithonaudiotools

# Будем работать с текстовыми файлами

# Открытие файла
f = open("test.txt", "r")
# Имя файла и режим, в котором мы хотим открыть, - намерение, с которым мы открываем данный файл

# Список режимов, в которых мы можем открыть текстовый файл /не все/:
# r (read) - открыть для чтения (по умолчанию)
# w (write) - открыть для записи, содержимое файла стирается
# a (append) - открыть для записи, запись ведется в конец
# b (binary) - открыть в бинарном режиме
# t (text) - открыть в текстовом режиме (по умолчанию)
# r+ - открыть для чтения и записи
# w+ - открыть для чтения и записи, содержимое файла стирается

# Мы можем сочетать данные режимы, т.е. указать rb, чтобы открыть файл для чтения в бинарном формате

# Функция open открывает fileobject
# Благодаря fileobject можно читать данные, записывать данные
# При этом fileobject нужно закрывать, когда Вы с файлом поработали
# f.close()

# Прежде всего в fileobject есть метод read
x = f.read(5) # В скобках передаются число символов, которые мы хотим считать из файла
print(x)
# Если параметр не указан, то считываем файл до конца
y = f.read()
print(y)
f.close()


f = open("test.txt", "r")

x = f.read()
print(y)

# Важно помнить, что символ переноса строки так же явдяется символом в Пайтон
# Выведем на экран не просто x, а представление x в качестве строки
print(repr(x))
f.close()

# Для того, чтобы разбить текст по строкам вне зависимости от ОС, в Пайтон есть метод splitlines()
x = x.splitlines()
print(repr(x))

# Может оказаться так, что файл очень большой и через read() займет слишком много места в оперативной памяти
# Поэтому имеет смысл считывать файл построчно
f = open("test.txt", "r")
x = f.readline()
print(repr(x))
# Для того, чтобы убрать символы переноса строки, можно воспользоваться rstrip()
# rstrip() убирает справа все пробельные символы
x = x.rstrip()
print(x)

# Однако более экономичным способом перебора строк является итерация по fileobject
# У fileobject есть итератор, и данный итератор каждый раз будет возвращать строку из файла
# Этот итератор написан эффективно по памяти

for line in f:
    line = line.rstrip()
    print(repr(line))
x = f.read()
print(x)
f.close()

# Если хотите считать n символов - read(n)
# Если хотите считать файл целиком - read()
# Если файл большой и хотите считывать его построчно - можете использовать цикл for и fileobject


# Запись в файл
f = open("test1.txt", "w") # Когда мы его откроем, мы его создадим
# Для записи строки в файл есть метод write()
f.write("Hello/n")
# Важно при использовании write использовать перенос строки, когда мы действительно хотим его использовать
f.write("hello")
f.close()

# Частой техникой, когда мы заранее знаем список строк, который мы хотим записать, является использовании функции join
f = open("test1.txt", "w") # Когда мы его откроем, мы его создадим
lines = ["Line 1", "Line 2", "Line 3"]
contents = "\n".join(lines)
f.write(contents)
f.close()

# Таким образом, join() склеивает строки в одну

# Как можно записать что-то в конец файла?
f = open("test_append.txt", "a")  # a - append
f.write("Hello\n")
f.close()

# С момента открытия до момента закрытия файла могла произойте ошибка
# Чтобы обезопасить себя от такой ситуации и чтобы перестать писать close() самим, мы можем использовать конструкцию with
with open("test.txt") as f:
    for line in f:
        line = line.rstrip()
        print(line)
# Такая конструкция гарантирует, что когда мы выйдем из блока with вне зависимости от того, произошла там ошибка
# или исполнение кода прошло нормально, интерпрретатор закроет наш файл. Поэтому такая конструкция является рекомендованной
# для работы с файлами

# Внутри with мы можем открыть сразу несколько файл. Для этого нужно перечислить их через запятую:
with open("test.txt") as f, open("test_copy.txt", "w") as w:
    for line in f:
        w.write(line)



# Однако работа с файловой системой не заканчивается лишь работой с файлами
# Библиотеки os и os.path

import os
import os.path

print(os.listdir()) # Можем перечислить файлы и папки внутри некоторой директории
# Если без аргументов - внутри текущей директории

# В нашем проекте существуе .idea, которую создает pycharm и кладет туда служебную информацию о проекте

# Чтобы узнать, какая директория является текущей, можем использовать функцию getcwd
print(os.getcwd())
print(os.listdir(".idea")) # Указываем относительный путь

# Для того, чтобы узнать, существует ли файл
print(os.path.exists("time.py"))
print(os.path.exists("random.py"))

# Функция exists работает не только для файлов, но и для директорий
print(os.path.exists(".idea"))

# Можем проверить, какой путь является папкой, какой путь является файлом
print(os.path.isfile("time.py"))
print(os.path.isfile(".idea"))
print(os.path.isdir("time.py"))
print(os.path.isdir(".idea"))

# Можем узнать абсолютный путь по относительному
print(os.path.abspath("time.py"))

# Можем сменить текущую директорию
print(os.getcwd())
os.chdir(".idea")
print(os.getcwd())
os.chdir("../")
print(os.getcwd())

# os.walk - Можем рекурсивно пройтись по всем папкам, подпапкам и т.д.
# Возвращает генератор
# И каждый раз, когда мы будем спрашивать следующее значение генератора, мы будем получать кортеж из трех элементов:
# строковое представление текущей директории; список всех подпапок в директории; список всех файлов в директории
for current_dir, dirs, files in os.walk("."):
     print(current_dir, dirs, files)

# Для копирования файлов библиотека shutil
import shutil
shutil.copy("tests/test1.txt", "tests/test2.txt")

# Можем скопировать целиком папку
shutil.copytree("tests", "tests/tests")

for current_dir, dirs, files in os.walk("."):
     print(current_dir, dirs, files)

# Работа с zip-архивами
# https://code.tutsplus.com/ru/tutorials/compressing-and-extracting-files-in-python--cms-26816
# Модуль zipfile